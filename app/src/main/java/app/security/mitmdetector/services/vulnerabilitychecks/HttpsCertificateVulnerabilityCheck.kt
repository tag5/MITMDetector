package app.security.mitmdetector.services.vulnerabilitychecks

import javax.inject.Singleton
import javax.inject.Inject
import android.util.Log
import app.security.mitmdetector.data.AuditResult
import java.net.InetSocketAddress
import java.net.Proxy
import java.net.URL
import java.security.cert.Certificate
import javax.net.ssl.HttpsURLConnection
import javax.net.ssl.SSLHandshakeException

@Singleton
class HttpsCertificateVulnerabilityCheck @Inject constructor(): VulnerabilityCheckBase() {
    override fun getCheckId(): String {
        return "https"
    }

    private fun extractPubKeyFromCertificate(certificates: Array<Certificate>): String?
    {
        for (certificate in certificates) {
            if (certificate is java.security.cert.X509Certificate && certificate.subjectDN.toString() == "CN=www.google.com") {
                val pubKey = certificate.publicKey.encoded.joinToString("") { b -> String.format("%02X", b) }
                return pubKey
            }
        }

        return null
    }

    override fun run(): AuditResult {
        val sslSession: javax.net.ssl.SSLSocket? = null

        try {
            val url = URL("https://www.google.com")
            val connection: HttpsURLConnection

            val httpsProxyHost = System.getProperty("https.proxyHost")
            val httpsProxyPort = System.getProperty("https.proxyPort")?.toIntOrNull()
            if (httpsProxyHost != null && httpsProxyPort != null) {
                val proxy = Proxy(Proxy.Type.HTTP, InetSocketAddress(httpsProxyHost, httpsProxyPort))
                connection = url.openConnection(proxy) as HttpsURLConnection
            }
            else {
                connection = url.openConnection() as HttpsURLConnection
            }

            connection.requestMethod = "GET"
            try {
                connection.connect()
            }
            catch (e: SSLHandshakeException) {
                Log.i("HttpsCertificateVulnerabilityCheck", "Wrong google certificate")
                return AuditResult.VulnerabilityDetected("Wrong google certificate")
            }
            val responseCode = connection.responseCode

            if (responseCode != 200) {
                Log.i("HttpsCertificateVulnerabilityCheck", "Wrong google response code")
                return AuditResult.VulnerabilityDetected("Wrong google response code")
            }

            val pubKey = extractPubKeyFromCertificate(connection.serverCertificates)
            if (pubKey==null) {
                Log.i("HttpsCertificateVulnerabilityCheck", "Can't extract Google certificate public key")
                return AuditResult.VulnerabilityDetected("Can't extract Google certificate public key")
            }

            // TODO: Google certificate public keys may change...
            if (pubKey!="3059301306072a8648ce3d020106082a8648ce3d030107034200049e2f279b0c96e6c1517387955e144728897a7f10bad4fb7964f36071a0aee75db161dc60c55df4dcc60a4ca1c167e9a9fa735ef0e7ad7670c4948a28c2f84f88"
                && pubKey!="3059301306072A8648CE3D020106082A8648CE3D030107034200049E325F191C59C2D00A8F69CF6E12EE0106C908929C662CE5E3D0971316C05C191EF05DDC7B1040FE0DAB02CCAB7CDEEFB92C70DA6E948CFD6E50BE02400ACF2F") {
                Log.i("HttpsCertificateVulnerabilityCheck", "Wrong Google public key in certificate: " + pubKey)
                return AuditResult.VulnerabilityDetected("Wrong Google public key in certificate")
            }

            Log.i("HttpsCertificateVulnerabilityCheck", "Google certificate public key OK")
            return AuditResult.NoAlert
        } catch (e: Exception) {
            Log.e("HttpsCertificateVulnerabilityCheck", "HttpsCertificateVulnerabilityCheck:" + e.toString())
            return AuditResult.Error(e.toString())
        } finally {
            sslSession?.close()
        }
    }
}